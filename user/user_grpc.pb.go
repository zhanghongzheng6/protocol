// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package user

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	// Get the specified user information full field
	GetDesignateUsers(ctx context.Context, in *GetDesignateUsersReq, opts ...grpc.CallOption) (*GetDesignateUsersResp, error)
	// update user information
	UpdateUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*UpdateUserInfoResp, error)
	UpdateUserInfoEx(ctx context.Context, in *UpdateUserInfoExReq, opts ...grpc.CallOption) (*UpdateUserInfoExResp, error)
	// Set user message receiving options
	SetGlobalRecvMessageOpt(ctx context.Context, in *SetGlobalRecvMessageOptReq, opts ...grpc.CallOption) (*SetGlobalRecvMessageOptResp, error)
	// Get the user message receiving option If not found, no error will be returned
	GetGlobalRecvMessageOpt(ctx context.Context, in *GetGlobalRecvMessageOptReq, opts ...grpc.CallOption) (*GetGlobalRecvMessageOptResp, error)
	// Check if userID exists
	AccountCheck(ctx context.Context, in *AccountCheckReq, opts ...grpc.CallOption) (*AccountCheckResp, error)
	// Turn the page (or specify userID, nickname) to pull user information Full field
	GetPaginationUsers(ctx context.Context, in *GetPaginationUsersReq, opts ...grpc.CallOption) (*GetPaginationUsersResp, error)
	// user registration
	UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error)
	// Get all user IDs
	GetAllUserID(ctx context.Context, in *GetAllUserIDReq, opts ...grpc.CallOption) (*GetAllUserIDResp, error)
	// Get the total number of users and the user increment within a specified time period
	UserRegisterCount(ctx context.Context, in *UserRegisterCountReq, opts ...grpc.CallOption) (*UserRegisterCountResp, error)
	// Subscribe or unsubscribe user presence
	SubscribeOrCancelUsersStatus(ctx context.Context, in *SubscribeOrCancelUsersStatusReq, opts ...grpc.CallOption) (*SubscribeOrCancelUsersStatusResp, error)
	// Get the online status of subscribers
	GetSubscribeUsersStatus(ctx context.Context, in *GetSubscribeUsersStatusReq, opts ...grpc.CallOption) (*GetSubscribeUsersStatusResp, error)
	// Get user online status
	GetUserStatus(ctx context.Context, in *GetUserStatusReq, opts ...grpc.CallOption) (*GetUserStatusResp, error)
	// The gateway synchronizes the online status of users in redis
	SetUserStatus(ctx context.Context, in *SetUserStatusReq, opts ...grpc.CallOption) (*SetUserStatusResp, error)
	// add a general function for add
	ProcessUserCommandAdd(ctx context.Context, in *ProcessUserCommandAddReq, opts ...grpc.CallOption) (*ProcessUserCommandAddResp, error)
	// add a general function for update
	ProcessUserCommandUpdate(ctx context.Context, in *ProcessUserCommandUpdateReq, opts ...grpc.CallOption) (*ProcessUserCommandUpdateResp, error)
	// add a general function for delete
	ProcessUserCommandDelete(ctx context.Context, in *ProcessUserCommandDeleteReq, opts ...grpc.CallOption) (*ProcessUserCommandDeleteResp, error)
	// add a general function for get
	ProcessUserCommandGet(ctx context.Context, in *ProcessUserCommandGetReq, opts ...grpc.CallOption) (*ProcessUserCommandGetResp, error)
	// add a general function for get all
	ProcessUserCommandGetAll(ctx context.Context, in *ProcessUserCommandGetAllReq, opts ...grpc.CallOption) (*ProcessUserCommandGetAllResp, error)
	// add a system notification account
	AddNotificationAccount(ctx context.Context, in *AddNotificationAccountReq, opts ...grpc.CallOption) (*AddNotificationAccountResp, error)
	// update the system notification info
	UpdateNotificationAccountInfo(ctx context.Context, in *UpdateNotificationAccountInfoReq, opts ...grpc.CallOption) (*UpdateNotificationAccountInfoResp, error)
	// search the system notification account
	SearchNotificationAccount(ctx context.Context, in *SearchNotificationAccountReq, opts ...grpc.CallOption) (*SearchNotificationAccountResp, error)
	// getNotificationAccount by userID
	GetNotificationAccount(ctx context.Context, in *GetNotificationAccountReq, opts ...grpc.CallOption) (*GetNotificationAccountResp, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) GetDesignateUsers(ctx context.Context, in *GetDesignateUsersReq, opts ...grpc.CallOption) (*GetDesignateUsersResp, error) {
	out := new(GetDesignateUsersResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/getDesignateUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*UpdateUserInfoResp, error) {
	out := new(UpdateUserInfoResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/updateUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateUserInfoEx(ctx context.Context, in *UpdateUserInfoExReq, opts ...grpc.CallOption) (*UpdateUserInfoExResp, error) {
	out := new(UpdateUserInfoExResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/updateUserInfoEx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetGlobalRecvMessageOpt(ctx context.Context, in *SetGlobalRecvMessageOptReq, opts ...grpc.CallOption) (*SetGlobalRecvMessageOptResp, error) {
	out := new(SetGlobalRecvMessageOptResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/setGlobalRecvMessageOpt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetGlobalRecvMessageOpt(ctx context.Context, in *GetGlobalRecvMessageOptReq, opts ...grpc.CallOption) (*GetGlobalRecvMessageOptResp, error) {
	out := new(GetGlobalRecvMessageOptResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/getGlobalRecvMessageOpt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) AccountCheck(ctx context.Context, in *AccountCheckReq, opts ...grpc.CallOption) (*AccountCheckResp, error) {
	out := new(AccountCheckResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/accountCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetPaginationUsers(ctx context.Context, in *GetPaginationUsersReq, opts ...grpc.CallOption) (*GetPaginationUsersResp, error) {
	out := new(GetPaginationUsersResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/getPaginationUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error) {
	out := new(UserRegisterResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/userRegister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetAllUserID(ctx context.Context, in *GetAllUserIDReq, opts ...grpc.CallOption) (*GetAllUserIDResp, error) {
	out := new(GetAllUserIDResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/getAllUserID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserRegisterCount(ctx context.Context, in *UserRegisterCountReq, opts ...grpc.CallOption) (*UserRegisterCountResp, error) {
	out := new(UserRegisterCountResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/userRegisterCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SubscribeOrCancelUsersStatus(ctx context.Context, in *SubscribeOrCancelUsersStatusReq, opts ...grpc.CallOption) (*SubscribeOrCancelUsersStatusResp, error) {
	out := new(SubscribeOrCancelUsersStatusResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/subscribeOrCancelUsersStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetSubscribeUsersStatus(ctx context.Context, in *GetSubscribeUsersStatusReq, opts ...grpc.CallOption) (*GetSubscribeUsersStatusResp, error) {
	out := new(GetSubscribeUsersStatusResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/getSubscribeUsersStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUserStatus(ctx context.Context, in *GetUserStatusReq, opts ...grpc.CallOption) (*GetUserStatusResp, error) {
	out := new(GetUserStatusResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/getUserStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetUserStatus(ctx context.Context, in *SetUserStatusReq, opts ...grpc.CallOption) (*SetUserStatusResp, error) {
	out := new(SetUserStatusResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/setUserStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ProcessUserCommandAdd(ctx context.Context, in *ProcessUserCommandAddReq, opts ...grpc.CallOption) (*ProcessUserCommandAddResp, error) {
	out := new(ProcessUserCommandAddResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/processUserCommandAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ProcessUserCommandUpdate(ctx context.Context, in *ProcessUserCommandUpdateReq, opts ...grpc.CallOption) (*ProcessUserCommandUpdateResp, error) {
	out := new(ProcessUserCommandUpdateResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/processUserCommandUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ProcessUserCommandDelete(ctx context.Context, in *ProcessUserCommandDeleteReq, opts ...grpc.CallOption) (*ProcessUserCommandDeleteResp, error) {
	out := new(ProcessUserCommandDeleteResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/processUserCommandDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ProcessUserCommandGet(ctx context.Context, in *ProcessUserCommandGetReq, opts ...grpc.CallOption) (*ProcessUserCommandGetResp, error) {
	out := new(ProcessUserCommandGetResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/processUserCommandGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ProcessUserCommandGetAll(ctx context.Context, in *ProcessUserCommandGetAllReq, opts ...grpc.CallOption) (*ProcessUserCommandGetAllResp, error) {
	out := new(ProcessUserCommandGetAllResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/processUserCommandGetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) AddNotificationAccount(ctx context.Context, in *AddNotificationAccountReq, opts ...grpc.CallOption) (*AddNotificationAccountResp, error) {
	out := new(AddNotificationAccountResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/addNotificationAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateNotificationAccountInfo(ctx context.Context, in *UpdateNotificationAccountInfoReq, opts ...grpc.CallOption) (*UpdateNotificationAccountInfoResp, error) {
	out := new(UpdateNotificationAccountInfoResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/updateNotificationAccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SearchNotificationAccount(ctx context.Context, in *SearchNotificationAccountReq, opts ...grpc.CallOption) (*SearchNotificationAccountResp, error) {
	out := new(SearchNotificationAccountResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/searchNotificationAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetNotificationAccount(ctx context.Context, in *GetNotificationAccountReq, opts ...grpc.CallOption) (*GetNotificationAccountResp, error) {
	out := new(GetNotificationAccountResp)
	err := c.cc.Invoke(ctx, "/openim.user.user/getNotificationAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	// Get the specified user information full field
	GetDesignateUsers(context.Context, *GetDesignateUsersReq) (*GetDesignateUsersResp, error)
	// update user information
	UpdateUserInfo(context.Context, *UpdateUserInfoReq) (*UpdateUserInfoResp, error)
	UpdateUserInfoEx(context.Context, *UpdateUserInfoExReq) (*UpdateUserInfoExResp, error)
	// Set user message receiving options
	SetGlobalRecvMessageOpt(context.Context, *SetGlobalRecvMessageOptReq) (*SetGlobalRecvMessageOptResp, error)
	// Get the user message receiving option If not found, no error will be returned
	GetGlobalRecvMessageOpt(context.Context, *GetGlobalRecvMessageOptReq) (*GetGlobalRecvMessageOptResp, error)
	// Check if userID exists
	AccountCheck(context.Context, *AccountCheckReq) (*AccountCheckResp, error)
	// Turn the page (or specify userID, nickname) to pull user information Full field
	GetPaginationUsers(context.Context, *GetPaginationUsersReq) (*GetPaginationUsersResp, error)
	// user registration
	UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error)
	// Get all user IDs
	GetAllUserID(context.Context, *GetAllUserIDReq) (*GetAllUserIDResp, error)
	// Get the total number of users and the user increment within a specified time period
	UserRegisterCount(context.Context, *UserRegisterCountReq) (*UserRegisterCountResp, error)
	// Subscribe or unsubscribe user presence
	SubscribeOrCancelUsersStatus(context.Context, *SubscribeOrCancelUsersStatusReq) (*SubscribeOrCancelUsersStatusResp, error)
	// Get the online status of subscribers
	GetSubscribeUsersStatus(context.Context, *GetSubscribeUsersStatusReq) (*GetSubscribeUsersStatusResp, error)
	// Get user online status
	GetUserStatus(context.Context, *GetUserStatusReq) (*GetUserStatusResp, error)
	// The gateway synchronizes the online status of users in redis
	SetUserStatus(context.Context, *SetUserStatusReq) (*SetUserStatusResp, error)
	// add a general function for add
	ProcessUserCommandAdd(context.Context, *ProcessUserCommandAddReq) (*ProcessUserCommandAddResp, error)
	// add a general function for update
	ProcessUserCommandUpdate(context.Context, *ProcessUserCommandUpdateReq) (*ProcessUserCommandUpdateResp, error)
	// add a general function for delete
	ProcessUserCommandDelete(context.Context, *ProcessUserCommandDeleteReq) (*ProcessUserCommandDeleteResp, error)
	// add a general function for get
	ProcessUserCommandGet(context.Context, *ProcessUserCommandGetReq) (*ProcessUserCommandGetResp, error)
	// add a general function for get all
	ProcessUserCommandGetAll(context.Context, *ProcessUserCommandGetAllReq) (*ProcessUserCommandGetAllResp, error)
	// add a system notification account
	AddNotificationAccount(context.Context, *AddNotificationAccountReq) (*AddNotificationAccountResp, error)
	// update the system notification info
	UpdateNotificationAccountInfo(context.Context, *UpdateNotificationAccountInfoReq) (*UpdateNotificationAccountInfoResp, error)
	// search the system notification account
	SearchNotificationAccount(context.Context, *SearchNotificationAccountReq) (*SearchNotificationAccountResp, error)
	// getNotificationAccount by userID
	GetNotificationAccount(context.Context, *GetNotificationAccountReq) (*GetNotificationAccountResp, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) GetDesignateUsers(context.Context, *GetDesignateUsersReq) (*GetDesignateUsersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDesignateUsers not implemented")
}
func (UnimplementedUserServer) UpdateUserInfo(context.Context, *UpdateUserInfoReq) (*UpdateUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedUserServer) UpdateUserInfoEx(context.Context, *UpdateUserInfoExReq) (*UpdateUserInfoExResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfoEx not implemented")
}
func (UnimplementedUserServer) SetGlobalRecvMessageOpt(context.Context, *SetGlobalRecvMessageOptReq) (*SetGlobalRecvMessageOptResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGlobalRecvMessageOpt not implemented")
}
func (UnimplementedUserServer) GetGlobalRecvMessageOpt(context.Context, *GetGlobalRecvMessageOptReq) (*GetGlobalRecvMessageOptResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGlobalRecvMessageOpt not implemented")
}
func (UnimplementedUserServer) AccountCheck(context.Context, *AccountCheckReq) (*AccountCheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountCheck not implemented")
}
func (UnimplementedUserServer) GetPaginationUsers(context.Context, *GetPaginationUsersReq) (*GetPaginationUsersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaginationUsers not implemented")
}
func (UnimplementedUserServer) UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (UnimplementedUserServer) GetAllUserID(context.Context, *GetAllUserIDReq) (*GetAllUserIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllUserID not implemented")
}
func (UnimplementedUserServer) UserRegisterCount(context.Context, *UserRegisterCountReq) (*UserRegisterCountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegisterCount not implemented")
}
func (UnimplementedUserServer) SubscribeOrCancelUsersStatus(context.Context, *SubscribeOrCancelUsersStatusReq) (*SubscribeOrCancelUsersStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeOrCancelUsersStatus not implemented")
}
func (UnimplementedUserServer) GetSubscribeUsersStatus(context.Context, *GetSubscribeUsersStatusReq) (*GetSubscribeUsersStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscribeUsersStatus not implemented")
}
func (UnimplementedUserServer) GetUserStatus(context.Context, *GetUserStatusReq) (*GetUserStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserStatus not implemented")
}
func (UnimplementedUserServer) SetUserStatus(context.Context, *SetUserStatusReq) (*SetUserStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserStatus not implemented")
}
func (UnimplementedUserServer) ProcessUserCommandAdd(context.Context, *ProcessUserCommandAddReq) (*ProcessUserCommandAddResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessUserCommandAdd not implemented")
}
func (UnimplementedUserServer) ProcessUserCommandUpdate(context.Context, *ProcessUserCommandUpdateReq) (*ProcessUserCommandUpdateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessUserCommandUpdate not implemented")
}
func (UnimplementedUserServer) ProcessUserCommandDelete(context.Context, *ProcessUserCommandDeleteReq) (*ProcessUserCommandDeleteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessUserCommandDelete not implemented")
}
func (UnimplementedUserServer) ProcessUserCommandGet(context.Context, *ProcessUserCommandGetReq) (*ProcessUserCommandGetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessUserCommandGet not implemented")
}
func (UnimplementedUserServer) ProcessUserCommandGetAll(context.Context, *ProcessUserCommandGetAllReq) (*ProcessUserCommandGetAllResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessUserCommandGetAll not implemented")
}
func (UnimplementedUserServer) AddNotificationAccount(context.Context, *AddNotificationAccountReq) (*AddNotificationAccountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNotificationAccount not implemented")
}
func (UnimplementedUserServer) UpdateNotificationAccountInfo(context.Context, *UpdateNotificationAccountInfoReq) (*UpdateNotificationAccountInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNotificationAccountInfo not implemented")
}
func (UnimplementedUserServer) SearchNotificationAccount(context.Context, *SearchNotificationAccountReq) (*SearchNotificationAccountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchNotificationAccount not implemented")
}
func (UnimplementedUserServer) GetNotificationAccount(context.Context, *GetNotificationAccountReq) (*GetNotificationAccountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationAccount not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_GetDesignateUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDesignateUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetDesignateUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/getDesignateUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetDesignateUsers(ctx, req.(*GetDesignateUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/updateUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateUserInfo(ctx, req.(*UpdateUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateUserInfoEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoExReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateUserInfoEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/updateUserInfoEx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateUserInfoEx(ctx, req.(*UpdateUserInfoExReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetGlobalRecvMessageOpt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGlobalRecvMessageOptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetGlobalRecvMessageOpt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/setGlobalRecvMessageOpt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetGlobalRecvMessageOpt(ctx, req.(*SetGlobalRecvMessageOptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetGlobalRecvMessageOpt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalRecvMessageOptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetGlobalRecvMessageOpt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/getGlobalRecvMessageOpt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetGlobalRecvMessageOpt(ctx, req.(*GetGlobalRecvMessageOptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_AccountCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountCheckReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).AccountCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/accountCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).AccountCheck(ctx, req.(*AccountCheckReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetPaginationUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaginationUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetPaginationUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/getPaginationUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetPaginationUsers(ctx, req.(*GetPaginationUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/userRegister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserRegister(ctx, req.(*UserRegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetAllUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllUserIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetAllUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/getAllUserID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetAllUserID(ctx, req.(*GetAllUserIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserRegisterCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserRegisterCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/userRegisterCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserRegisterCount(ctx, req.(*UserRegisterCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SubscribeOrCancelUsersStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeOrCancelUsersStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SubscribeOrCancelUsersStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/subscribeOrCancelUsersStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SubscribeOrCancelUsersStatus(ctx, req.(*SubscribeOrCancelUsersStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetSubscribeUsersStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscribeUsersStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetSubscribeUsersStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/getSubscribeUsersStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetSubscribeUsersStatus(ctx, req.(*GetSubscribeUsersStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUserStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUserStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/getUserStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUserStatus(ctx, req.(*GetUserStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetUserStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetUserStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/setUserStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetUserStatus(ctx, req.(*SetUserStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ProcessUserCommandAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessUserCommandAddReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ProcessUserCommandAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/processUserCommandAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ProcessUserCommandAdd(ctx, req.(*ProcessUserCommandAddReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ProcessUserCommandUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessUserCommandUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ProcessUserCommandUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/processUserCommandUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ProcessUserCommandUpdate(ctx, req.(*ProcessUserCommandUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ProcessUserCommandDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessUserCommandDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ProcessUserCommandDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/processUserCommandDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ProcessUserCommandDelete(ctx, req.(*ProcessUserCommandDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ProcessUserCommandGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessUserCommandGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ProcessUserCommandGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/processUserCommandGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ProcessUserCommandGet(ctx, req.(*ProcessUserCommandGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ProcessUserCommandGetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessUserCommandGetAllReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ProcessUserCommandGetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/processUserCommandGetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ProcessUserCommandGetAll(ctx, req.(*ProcessUserCommandGetAllReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_AddNotificationAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNotificationAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).AddNotificationAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/addNotificationAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).AddNotificationAccount(ctx, req.(*AddNotificationAccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateNotificationAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNotificationAccountInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateNotificationAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/updateNotificationAccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateNotificationAccountInfo(ctx, req.(*UpdateNotificationAccountInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SearchNotificationAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchNotificationAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SearchNotificationAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/searchNotificationAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SearchNotificationAccount(ctx, req.(*SearchNotificationAccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetNotificationAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetNotificationAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openim.user.user/getNotificationAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetNotificationAccount(ctx, req.(*GetNotificationAccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "openim.user.user",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getDesignateUsers",
			Handler:    _User_GetDesignateUsers_Handler,
		},
		{
			MethodName: "updateUserInfo",
			Handler:    _User_UpdateUserInfo_Handler,
		},
		{
			MethodName: "updateUserInfoEx",
			Handler:    _User_UpdateUserInfoEx_Handler,
		},
		{
			MethodName: "setGlobalRecvMessageOpt",
			Handler:    _User_SetGlobalRecvMessageOpt_Handler,
		},
		{
			MethodName: "getGlobalRecvMessageOpt",
			Handler:    _User_GetGlobalRecvMessageOpt_Handler,
		},
		{
			MethodName: "accountCheck",
			Handler:    _User_AccountCheck_Handler,
		},
		{
			MethodName: "getPaginationUsers",
			Handler:    _User_GetPaginationUsers_Handler,
		},
		{
			MethodName: "userRegister",
			Handler:    _User_UserRegister_Handler,
		},
		{
			MethodName: "getAllUserID",
			Handler:    _User_GetAllUserID_Handler,
		},
		{
			MethodName: "userRegisterCount",
			Handler:    _User_UserRegisterCount_Handler,
		},
		{
			MethodName: "subscribeOrCancelUsersStatus",
			Handler:    _User_SubscribeOrCancelUsersStatus_Handler,
		},
		{
			MethodName: "getSubscribeUsersStatus",
			Handler:    _User_GetSubscribeUsersStatus_Handler,
		},
		{
			MethodName: "getUserStatus",
			Handler:    _User_GetUserStatus_Handler,
		},
		{
			MethodName: "setUserStatus",
			Handler:    _User_SetUserStatus_Handler,
		},
		{
			MethodName: "processUserCommandAdd",
			Handler:    _User_ProcessUserCommandAdd_Handler,
		},
		{
			MethodName: "processUserCommandUpdate",
			Handler:    _User_ProcessUserCommandUpdate_Handler,
		},
		{
			MethodName: "processUserCommandDelete",
			Handler:    _User_ProcessUserCommandDelete_Handler,
		},
		{
			MethodName: "processUserCommandGet",
			Handler:    _User_ProcessUserCommandGet_Handler,
		},
		{
			MethodName: "processUserCommandGetAll",
			Handler:    _User_ProcessUserCommandGetAll_Handler,
		},
		{
			MethodName: "addNotificationAccount",
			Handler:    _User_AddNotificationAccount_Handler,
		},
		{
			MethodName: "updateNotificationAccountInfo",
			Handler:    _User_UpdateNotificationAccountInfo_Handler,
		},
		{
			MethodName: "searchNotificationAccount",
			Handler:    _User_SearchNotificationAccount_Handler,
		},
		{
			MethodName: "getNotificationAccount",
			Handler:    _User_GetNotificationAccount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user/user.proto",
}
